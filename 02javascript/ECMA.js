/* ECMA
 */

/* 常量 表示一些固定不变的数据
整型常量：整数
实型常量：小数
字符串常量：
布尔常量：ture/false
自定义常量：ES6中新增的 const 常量名称 = 常量取值（不可改变）
 */

/* 变量 表示一些可以被修改的数据
var 变量名称 = 变量取值
变量间可以相互赋值
ES6之前可重复var 相同名称变量，后var的会覆盖前一个（是否会先抹去之前var占用的内容空间，然后重新占另一个内存空间）
ES6之前浏览器在解析JS代码之前会进行预解析（预处理）操作
预解析（预处理）：将当前JS代码中所有变量的定义和函数的定义放到所有代码的最前面，因此先使用后定义在ES6之前也是可以的，当前不可以
let 变量名称 = 变量取值 
let 不可重复定义同名变量，浏览器不会对let定义的变量进行预解析，所以不可以先使用后定义

全局变量与局部变量的区别：
1.有效范围不同：全局变量有效范围是从定义变量的那一行起直到文件末尾都可以使用；
局部变量有效范围是从定义变量的那一行开始知道大括号结束位置（只有在大括号中有效）；var定义的变量不区分局部变量和全局变量，后续都可以被使用。

 */

/* 关键字 被JS语言赋予了特殊含义的单词
关键字不能用作变量、函数的名称；
关键字严格区分大小写、多为小写
 */

/* 标识符 为了将莫些东西区分出来的符号（变量名称）
标识符命名规则：
英文字母大小写、阿拉伯数字0~9、下划线_、美元符号$组成
不能以数字开头
严格区分大小写
不可以使用关键字、保留字作为标识符
 */

/* 数据
静态数据：永久的数据，一般存在硬盘中，只要硬盘不损坏，数据永远存在
动态数据：在程序运行中，动态产生的临时数据，一般存储在内存中，数据会在关机重启后会被清空
*/

/* 数据类型 动态数据类型
Number 数值 NaN为数值类型
String 字符串
Boolean 布尔
Undefined 未定义
Null 空值（以上为基本数据类型）
Object 对象(引用数据类型)

数据类型检测：typeof 需要检测的数据  数值的特殊值 NaN 用 isNaN(num)进行判断
*/

/* 数据类型转换 转换为字符串类型
将 数值 数据类型转换为字符串类型： 常量or变量 + ''/String(变量or常量)/变量名称.toString()
将 布尔 数据类型转换为字符串类型：常量or变量 + ''/String(变量or常量)/变量名称.toString()
将 undefined 数据类型转换为字符串类型：常量or变量/+ '' String(变量or常量)
将 null 数据类型转换为字符串类型：常量or变量 + ''/String(变量or常量)

常量or变量 + ''：最简单的方式将所有类型的常量和变量转换为字符串类型，并不会改变原有数据的数据类型
String(变量or常量)：可以将所有类型的常量和变量转换为字符串类型（重新生成），并不会改变原有数据的数据类型
变量名称.toString()：是将拷贝的变量的数据类型进行转换，并不会改变原有变量的数据类型
*/

/* 数据类型转换 转换为数值类型 
将 字符串 数据类型转换为字符串类型：Number(变量or常量) +/- 常量or变量 parseInt/parseFloat
将 布尔 数据类型转换为字符串类型：Number(变量or常量) +/- 常量or变量 parseInt/parseFloat
将 undefined 数据类型转换为字符串类型：Number(变量or常量) +/- 常量or变量 parseInt/parseFloat
将 null 数据类型转换为字符串类型：Number(变量or常量) +/- 常量or变量 parseInt/parseFloat

Number(变量or常量)：可以将所有类型的常量和变量转换为数值类型（重新生成），并不会改变原有数据的数据类型,
字符串如果为空字符串转换结果为0，如果字符串中的数据不仅仅是数值转换结果为NaN(not a number)
布尔值true/false的转换结果为1/0
undefined的转换结果为NaN
null 转换结果为0

+/- 常量or变量：+'123' 减号会改变变量的正负值

parseInt/parseFloat：可将字符串中的数字提取出来，parseInt只提取整数部分，parseFloat提取小数；都会把要处理的数据当成字符串处理，
只能提取第一个为数字的字符串，若第一个不是则返回NaN。
*/

/* 数据类型转换 转换为布尔类型 
将 字符串 数据类型转换为布尔类型：Boolean(变量or常量) 空字符串转换结果为false 其他包括空格都为true
将 数值 数据类型转换为布尔类型：Boolean(变量or常量) 0及NaN转换结果为false 其他为true
将 undefined 数据类型转换为布尔类型：Boolean(变量or常量) 转换结果为false
将 null 数据类型转换为布尔类型：Boolean(变量or常量) 转换结果为false
 */

/* 运算符
按功能分类：算术运算符 位运算符 关系运算符 逻辑运算符
按操作数分类：单目运算 双目运算 三目运算（a==b?1:2） （操作数的数量，及常量/变量的个数）

优先级和结合性：结合性是指运算类似从左往右的运算顺序

算术运算符：+ - * / %  结合性从左往右，* / % 优先级大于+ -；
加法运算注意点：
1.数字与字符串相加，都会先转换成字符串再运算，即字符串拼接
2.除去字符串后任何非数值类型的数据参与加法运算之前，都会被自动转换成数值类型之后，再参与运算
3.任何数据与NaN进行运算结果都是NaN
减法运算注意点：
数字与字符串相减，会先转换成数值类型，再进行减法，其余相同
乘除法运算注意点：
与减法运算相同
取余运算注意点：
1.如果分子大于分母则正常取余，如果分子小于分母，则结果为分子  3 % 10 = 3
2.如果分母为0，则结果为NaN
3.取余结果的正负取决于 分子 -10 % 3 = -1

赋值运算符（位运算符？）：= += -= *= /= %= 
1.优先级低于算数运算符，算数运算结束后进行赋值运算
2.运算符左边只能放变量
3. res += 5 相当于 res = res + 5
4. res -= 5 相当于 res = res - 5
5. res *= 5 相当于 res = res * 5
6. res %= 5 相当于 res = res % 5

自增自减运算符：num++/++num num--/++num
1.num++ 先进行其他操作再进行++  let num = 1; num++ + 1 = 2（尽量不用此方法）
2.++num 先进行++再进行其他操作  let num = 1; ++num + 1 = 3（尽量不用此方法）
3.num--/++num 与 num++/++num 相同
4.++/-- 只能应用于变量 不能应用于常量及表达式上

关系运算符：> < >= <= == != === !== 结果返回 true/false 
1.若运算中含字符串，先将字符串转为数字再进行比较
2.任何数据与NaN/undefined做比较返回结果都是false 包括  两个NaN作比较
3.如果两个参与比较的数据都为字符串，那么就会逐个比较两个字符串单个符的unicode大小直到条件不满足为止
4.特殊比较的结果：null == 0 为false; null == undefined 为 true; NaN == NaN 为false 
5.===恒等于/!==不恒等于：会判断数据类型
6.关系运算符是左结合性，也就是从左至右依次比较，所以不能用来判断区间，但> < >= <= 的优先级大于 == != === !==

逻辑运算符：&& || ! 与 或 非 左结合性， && 优先级 大于 || 
1.如果条件不属于布尔类型，先转换成布尔类型再参与其他运算
2.&& 的运算中，如果条件不是布尔类型，返回值有一个特点：
格式：条件A && 条件B
如果条件A不成立为false，那么返回条件A
如果条件A成立为true，那么无论条件B是否成立，都会返回条件B
3.|| 的运算中，如果条件不是布尔类型，返回值有一个特点：
格式：条件A || 条件B
如果条件A成立为true，那么返回条件A
如果条件A不成立为false，那么无论条件B是否成立，都会返回条件B
4.&& 的运算中有一个短路的现象
格式：条件A && 条件B
由于逻辑与运算的规则是一假则假，所以只要条件A是假，那么条件B就不会运算
5.|| 的运算中有一个短路的现象
格式：条件A || 条件B
由于逻辑或运算的规则是一真则真，所以只要条件A是真，那么条件B就不会运算

逗号运算符： B
1.逗号一般用于简化代码  比如 利用逗号运算符定义多个变量
2.逗号运算符为左结合性，逗号运算符的优先级是所有运算符中最低的
3.逗号运算符的运算结果就是最后一个表达式的结果

三目运算符（条件运算符）：条件表达式 ? 结果A : 结果B

  */

/* 流程控制 顺序、选择、循环三种基本控制结构
选择结构：if switch
if：
switch：
switch(表达式) {
  case 表达式A:(绝对等于)
    语句A
    break;
  case 表达式A:
    语句A
    break;
    ... ...
  default: 
    前面所有case都不匹配执行的代码
    break;
}

循环结构：
while：
while(条件表达式){
  ...
}
死循环：条件表达式永远为真的循环结构我们称之为死循环

dowhile：先执行一次循环体，再进行判断
do {
  需要重复执行的代码
}while (条件表达式);

for: 
for(let num = 1;num<10;num++) {
  需重复执行的代码
}
1.初始化表达式、条件表达式、循环增量表达式都可省略 等于 while(1)死循环

打破循环关键字：
break：立即结束当前循环结构（整个循环，在嵌套循环时，结束所在循环，不影响外部循环），可用在switch语句以及循环结构中
continue：跳过本次循环，进入下次循环，只能用在循环结构中
  */

/* 数组
ES6数组解构赋值：[a,b,[c,d]] = [1,2,[3,4]]
注意点：1、格式需相同；2、左右数据个数可不相等，如果右侧个数少，那么左边剩余变量赋值为undefined；3、左边变量可设默认值 [a=11,b=22,c=33] = [1,2] 
4、扩展运算符：let [a,...b] = [1,2,3,4,5]  放在左边表示将剩余数据打包
let res = [...arr1,...arr2]放在右侧将数组中的值取出来
数组的增删改查：
arr.splice(开始的index,修改几个,改成的值,...)替换多个值；arr.splice(1,1)从index为1的元素开始，删除一条数据；arr.splice(n,arr.length-n)删除使数组剩余n个元素
arr.push(1)数组后方新增一条数据，会修改原数组，返回数组长度
arr.unshift(2)数组前方新增一条数据，会修改原数组，返回数组长度
arr.pop()删除数组的最后一条数据，会修改原数组，返回被删除的数据
arr.shift()删除数组的第一条数据，会修改原数组，返回被删除的数据
arr.toString()将数组转换为字符串
arr.join('*')将数组元素以'*'拼接为字符串
let arrn = arr1.concat(arr2)将数组arr2拼接到arr1后面，不会改变原数组，返回新的数组 ES6: let res = [...arr1,...arr2]
arr.reverse()将数组倒序排列，会修改原有数组
let res = arr.slice(1,2)截取数组中的片段，包头不包尾，不会对原有数组进行修改，返回截取的片段
let num = arr.indexOf(3需要查找的元素,4查找开始的index值)查找数组中第一个3的位置index，如果数组中不包含3则返回-1  let num = arr.lastIndexOf(3,4)从后开查
可以通过indexOf()和lastIndexOf()的返回值是否是-1来判断数组中是否包含某个值
ES6 arr.includes(3) 直接返回true/false
arr.fill(0)将数组所有元素变成0
   */

//数组计数排序：
//缺点：无法对负数排序，对数值较大的排序不友好

(function () {
  let arr = [9, 2, 3, 9, 1];
  let res = new Array(10);
  let c = [];
  res.fill(0);
  for (let i = 0; i < arr.length; i++) {
    let ri = arr[i]
    res[ri] = res[ri] + 1
  }
  for (let i = 0; i < res.length; i++) {
    for (let j = 0; j < res[i]; j++) {
      c.push(i)
    }
  }
  console.log('计数排序法：', c)
})();

//数组选择排序
(function () {
  let arr = [6, -3, 100, 8, 6]
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] > arr[j]) {
        [arr[i], arr[j]] = [arr[j], arr[i]]
      }
    }
  }
  console.log('选择排序法：', arr)
})();

//数组冒泡排序
(function () {
  let arr = [6, -3, 100, 8, 6]
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
      }
    }
  }
  console.log('冒泡排序法：', arr)
})();

/*函数 专门用于封装代码 是一段可以被反复执行的代码块 function say() {执行代码} let say = function() {}
arguments 函数是所有实参的伪数组
函数扩展运算符：let [a,...b] = [1,2,3,4,5]  放在左边表示将剩余数据打包 let res = [...arr1,...arr2]放在右侧将数组中的值取出来
*/

//函数扩展运算符例子
(function() {
  function getSum(...values) {
    let sum = 0;
    for(let i=0;i<values.length;i++) {
      sum += values[i]
    }
    console.log('函数扩展运算符：',sum)
  }
  getSum(10,20,30)
})();

//函数作为其他函数的参数
(function() {
  let say = function() {
    console.log('函数作为其他函数的参数')
  }
  function test(fn) {
    fn()
  }
  test(say)
})();

//函数作为其他函数的返回值
(function() {
  function test() {
    let say = function() {
      console.log('函数作为其他函数的返回值')
    }
    return say;
  }
  let fn = test();
  fn()
})();

/*匿名函数 没有名字的函数 function () {执行代码}
使用场景：作为其他函数的参数；作为其他函数的返回值；作为一个立即执行函数(function () {执行代码})()；

箭头函数 ES6 
*/